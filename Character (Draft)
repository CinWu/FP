//A new turn resets _HasMoved, _HasAttacked, _UsedItem;


public abstract class Character{

    protected String _Name;
    protected String _Class;
    protected int _Exp;
    protected int _NextLvl;
    protected int _Lvl;
    protected int _HP;
    protected int _MaxHP;
    protected int _MP;
    protected int _MaxMP;
    protected int _InitATK;
    protected int _ATK;
    protected int _InitDEF;
    protected int _DEF;
    protected int _InitSPATK;
    protected int _SPATK;
    protected int _InitSPDEF;
    protected int _SPDEF;
    protected int _InitSPD;
    protected int _SPD;
    protected int _InitACC;
    protected int _ACC;
    protected int _InitEVS;
    protected int _EVS;
    protected int _Magic; //This is for slight MP regen after each turn
    
    protected int _HPPots;
    protected int _MPPots;
    protected int _StatCures;

    protected int _Move;
    protected String _Left;
    protected String _Right;
    protected String _Forward;
    protected String _Back;

    protected int xcor;
    protected int ycor;

    //*****************Counters*****************

    protected boolean _HasMoved;
    protected boolean _UsedAction; // this will determine whether or not they have used an attack or an item because in games I've played, you normally can't do both in one turn
    protected boolean _IsStandby; //for similar reasons as above, once the player selects a "standby" or "wait" position, they are not allowed to reselect and use the character again, even if they did not move or attack before.
    protected boolean _IsAlive;

    //*******************************************
    
    public Character(){

	_Lvl = 1;
	_NextLvl = 100;
	_Exp = 0;

    }

    //**************All of them gets*************
    
    protected String _Namu2;
    protected String _Namu4;

    public String getName() {
	return _Name;
    }
    public String getNamu1() { return "Attack"; }//...action names
    public abstract String getNamu2();//...action names
    public String getNamu3() { return "Defend"; };//...action names
    public String getNamu4() { return "Item" }//...action names

    public int getLvl() {
        return _Lvl;
    }
    public int getMaxHP() {
	return _MaxHP;
    }
    public int getHP() {
        return _HP;
    }
    public int getMP() {
        return _MP;
    }
    public int getATK() {
        return _ATK;
    }
    public int getDEF() { 
        return _DEF;
    }
    public int getInitATK() {
        return _InitATK;
    }
    public int getInitDEF() {
        return _InitDEF;
    }
    public int getSPATK() {
        return _ATK;
    }
    public int getSPDEF() {
        return _DEF;
    }
    public int getInitSPATK() {
        return _InitSPATK;
    }
    public int getInitSPDEF() {
        return _InitSPDEF;
    }
    public int getSPD() {
        return _SPD;
    }
    public int getPosX() {
	return xcor;
    }
    public int getPosY() {
	return ycor;
    }
    public boolean usedAction() {
	return _UsedAction;
    }
    public boolean hasMoved() {
	return _HasMoved;
    }
    public boolean isStandby() {
	return _IsStandby;
    }


    //blahblahblah

    //*******************************************
    
    public boolean isAlive() {
        if (_HP <= 0) {
         return false;
        }
        return true;
    }

    public void setXY( int x, int y ) {

	xcor = x;
	ycor = y;

    }

    public void setStandby( boolean q ) {
	_IsStandby = q;
    }

    public void move( int x, int y ) { //? because maybe grids work differently
        
        int xDir = x;
        int yDir = y;
 
        
        //if statement: abs(xDir) + abs(yDir) <= max number of boxes a character can move.        
        //xDir = how many boxes the character moved in the x direction
        //yDir = how many boxes the character moved in the y direction

    }

    //********************ACTIONS*****************************
    //Will each have separate action names depending on job/class

    public abstract void action1(Character c); //Specific for jobs/classes.
    //will most likely be a regular attack using the character's equiped weapon, even the squishy mage's wooden staff that does like 5 damage
           
    public abstract int action2(Character c);//Actions 2 and 3 will probably be MP based. Action 2 will probably be an attack. Or maybe a defense.

    public void action3() {
	gainDEF(5);
	gainSPDEF(5);
	_UsedAction = true;
    }
    public void action4() {
	int i = _Inventory.size();
	if ( i == 0 ) {
	    System.out.println("No items to use!");
	}
	else {
	    String l = "Use which item?\n";
	    for ( int r = 0; r < i ; i++ ) {
		l += "\t" + r + ": " + _Inventory.get(r);
	    }
	    System.out.print( l );
	    _UsedAction = true;
	}
    }


    //********Battle Mechanisms*********
    
    public void lvlUp() {
        
        if ( _Exp >= _NextLvl ) {
        
         _Lvl ++;
         _Exp = _NextLvl - _Exp;
         _NextLvl = 100 + 50*_Lvl;
         System.out.println( "has leveled up!" );

        }
    }
    
    public void gainExp( Character c ) {

        int expGain;

	if ( !( c.isAlive() ) ) {
	    expGain = (int)( c.getLvl()*.6 );
	    _Exp += expGain;
	    lvlUp();
	    System.out.println( "gained" + expGain + "exp!" );
        }
    }

    public int loseHP( int dam ) {
	_HP -= dam;
	if ( _HP < 0 ) 
	    _HP = 0;
	return _HP;
    }
    public int loseMP( int m ) {
	_MP -= m;
	if ( _MP < 0 )
	    _MP = 0;
	return _MP;
    }
    public int loseATK( int a ) {
	_ATK -= a;
	return _ATK;
    }
    public int loseDEF( int d ) {
	_DEF -= d;
	return _DEF;
    }
    public int loseSPATK( int spa ) {
	_SPATK -= spa;
	return _SPATK;
    }
    public int loseSPDEF( int spd ) {
	_SPDEF -= spd;
	return _SPDEF;
    }
    public int loseSPD( int s ) {
	_SPD -= s;
	return _SPD;
    }
    public int loseEVS( int evs ) {
	_EVS -= evs;
	return _EVS;
    }
    public int loseACC( int acc ) {
	_ACC -= acc;
	return _ACC;
    }
    public int gainHP( int h ) {
	_HP += h;
	if ( _HP > _MaxHP ) {
	    _HP = _MaxHP;
	}
	return _HP;	
    }
    public int gainMP( int m ) {
	_MP += m;
	if ( _MP > _MaxMP ) {
	    _MP = _MaxMP;
	}
	return _HP;	
    }
    public int gainATK( int a ) {
	_ATK += a;
	return _ATK;
    }
    public int gainDEF( int d ) {
	_DEF += d;
	return _DEF;
    }
    public int gainSPATK( int spa ) {
	_SPATK += spa;
	return _SPATK;
    }
    public int gainSPDEF( int spd ) {
	_SPDEF += spd;
	return _SPDEF;
    }
    public int gainSPD( int s ) {
	_SPD += s;
	return _SPD;
    }
    public int gainEVS( int evs ) {
	_EVS += evs;
	return _EVS;
    }
    public int gainACC( int acc ) {
	_ACC += acc;
	return _ACC;
    }

    public int attack( Character c, int lo, int hi, int dam, int x, int y ) {
	
	if ( Math.abs( c.getPosX() - x ) + Math.abs( c.getPosY() - y ) >= lo
	     &&
	     Math.abs( c.getPosX() - x ) + Math.abs( c.getPosY() - y ) <= hi
	     ) {
	    System.out.println( "Success" );
	    c.loseHP(dam);
	    gainExp( c );
	    _UsedAction = true;
	}
	else 
	    System.out.println( "Target not within range." );
	
	return dam;
    }
    

    public String toString() {
	String s = "=======Stats=======";
	s += "\nName: " + _Name;
	s += "\nClass: " + _Class;
	s += "\nLevel: " + _Lvl;
	s += "\nNext Level: " + (_NextLvl - _Exp);
	s += "\nHP: " + _HP;
	s += "\nMP: " + _MP;
	s += "\nAttack: " + _ATK;
	s += "\nMagic: " + _SPATK;
	s += "\nDefense: " + _DEF;	
	s += "\nMagic Defense: " + _SPDEF;	
	s += "\nSpeed: " + _SPD;	
	s += "\nAccuracy: " + _ACC;	
	s += "\nEvasion: " + _EVS;
	s += "\n===================\n\n";
	return s;
    }
}













    //*********************Some older methods, may be useful********************

    public int getDefense(){
        return _Def;
    }
    
    public int getEvasion(){
        return _Evasion;
    }

    public int getLuck(){
        return _Luck;
    }

    public int getLevel(){
        return _Level;
    }

    public int getMP(){
        return _MP;
    }



//Yay level up system! Does what a normal lvl up system does. Excess EXP is carried over when you lvl up.
    public int lvlUp(){
        if ( _CurrentExp > _NextLevelExp ){
         _Level += 1;
         _CurrentExp = _CurrentExp - _NextLevelExp;
         _NextLevelExp = 100*( _Level*(4/3) );
         statsUp();
         System.out.print( "You have leveled up!" );
        }
        return _Level;
    }

//EXP gain every time a monster dies. (In this case smaug) This is put in the YoRPG class when smaug dies
    public int expGain( Monster c ){
        _CurrentExp += c.dropExp();
        System.out.println("You have gained " + c.dropExp() + " EXP!");
        lvlUp();
        return _CurrentExp;
    }
    
// //Grams gain every time a monster dies.
//         public int gramGain ( Monster c ) {
//         _Grams += c.dropGram();
//         System.out.println("You have gained " + c.dropGram() + " Grams!");
//         System.out.println("You have " + _Grams + "Grams!");
//         return _Grams;
//     }

//     public void lowerGram ( int d ) {
//         if (_Grams > d) {
//             _Grams -= d;
//             System.out.printn("You have " + _Grams + "Grams!");
//         }
//     }
    
    public boolean fleed(){
        if ( (int) (Math.random()*_Luck + 10) < _Luck ){
         return true; }
        return false;
    }
//if random int 0 - _Luck + 10 < _luck, escape from battle. else you're stuck.


    public void lowerHP( int d ){
        _HP -= d;
        System.out.println(getName()+" HP: "+_HP);
    }
//subtract health, does not need to return anything, could return current health though

    public void gainMP( int d ) {
        if ((_MP + d) < _MaxMP) {
            _MP += d;
        }
        else {
            _MP = _MaxMP;
        }
    }
    // adds mana, does not return anything

    public boolean hasHit( Character c ){
        if (((int) (Math.random()*_Accuracy)) >= ((int) (Math.random()*c.getEvasion()))){
         return true; }
        return false;
    }
//Choses a random int from 0 to _accuracy of attacker,
//and checks if that is greater than a random int from 0 to _evasion of the defender.
//If it is > the attack will go through. (see attack method)


    public void attack( Character c ){
        if ( hasHit( c ) ) {
         int damage = (int) ((_Attack*_AttackRating) - _TmpDef);
         if ( damage < 0 ){
                damage = 0;
         }
         c.lowerHP( damage );
         System.out.println(c.getName()+" took "+damage+" damage."); }
//prints the amount of damage the opposing side takes, so there is no need for this in the driver class.
//Same for the bottom line, except the character has missed their attack and no damage is dealt.
        else {
         System.out.println(getName()+" has missed!");        }
    }



    public abstract String getName();
    //get name of char if it has

    public abstract void statsUp();
    //increase stats according to char when level up.



    public String tellAbout() {
        return _About;
    }

}
